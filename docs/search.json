[
  {
    "objectID": "TODO.html",
    "href": "TODO.html",
    "title": "C++",
    "section": "",
    "text": "라이브러리 종류: 정적 라이브러리(STATIC)와 공유 라이브러리(SHARED) 외에도 MODULE 라이브러리도 있습니다. 각 라이브러리의 특징과 사용 시나리오를 알아보는 것도 좋습니다.\n헤더 파일 관리: 예제에서는 간단하게 헤더 파일을 직접 포함했지만, 실제 프로젝트에서는 헤더 파일 설치와 같이 체계적인 관리가 필요할 수 있습니다.\n빌드 타입: 빌드 타입(Debug, Release 등)에 따라 컴파일 옵션이나 링커 옵션을 다르게 설정하는 방법을 알아보세요.\n외부 라이브러리: find_package 명령어를 사용하여 외부 라이브러리를 찾고 연결하는 방법을 익히세요.\n소스 코드 구조: add_subdirectory를 사용하여 프로젝트를 여러 하위 디렉토리로 나누어 관리하는 방법을 알아보세요.\n테스트: CTest를 사용하여 작성한 코드를 테스트하는 방법을 알아보세요.\n코드 품질: clang-tidy와 같은 코드 분석 도구를 사용하여 코드 품질을 개선하는 방법을 알아보세요.\n패키징: CPack을 사용하여 빌드 결과물을 패키징하는 방법을 알아보세요."
  },
  {
    "objectID": "notes/cpp_01.html",
    "href": "notes/cpp_01.html",
    "title": "C++ 개발 환경 구성과 CMake",
    "section": "",
    "text": "CMake를 사용해서 실행 파일을 만드는 과정을 통해 CMake의 기본적인 사용법을 연습하는 간단한 과정을 소개해드리겠습니다.\n\n소스 코드: src/main.cpp 파일에 “Hello, World!”를 출력하는 C++ 코드를 작성합니다.\nCMake 설정: CMakeLists.txt 파일에 CMake 프로젝트 설정을 정의하고, 실행 파일 타겟을 생성하고 소스 파일을 연결합니다.\n빌드: 명령 줄에서 CMake를 사용하여 프로젝트를 구성하고 빌드합니다.\n실행: 빌드된 실행 파일을 실행하여 “Hello, World!”가 출력되는지 확인합니다.\n\n\n\n\nsrc/main.cpp\n\n이 파일은 표준 출력 스트림을 사용하여 “Hello, World!”를 출력하는 간단한 C++ 프로그램입니다.\n#include &lt;iostream&gt;\n\nint main()\n{\n    std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; std::endl;\n    return 0;\n}\n\nCMakeLists.txt 파일\n\ncmake_minimum_required(VERSION 3.21): 이 명령어는 합니다. 3.21 버전 이상에서 이 프로젝트를 빌드해야 합니다.\nproject(...): 프로젝트 이름, 버전, 설명, 사용 언어 등을 설정합니다.\nadd_executable(hello_world): hello_world라는 실행 파일 타겟을 생성합니다.\ntarget_sources(hello_world PRIVATE src/main.cpp): hello_world 타겟에 소스 파일 src/main.cpp를 연결합니다. PRIVATE 키워드는 이 소스 파일이 현재 타겟에서만 사용됨을 의미합니다.\n\n\ncmake_minimum_required(VERSION 3.21) \n\nproject(HelloWorld VERSION 1.0\n  DESCRIPTION \"A simple Hello World project with CMake\"\n  LANGUAGES CXX\n)\n\nadd_executable(hello_world)\ntarget_sources(hello_world PRIVATE src/main.cpp)\n\n\n\n다음은 명령 줄에서 프로젝트를 빌드하고 실행하는 단계입니다.\n\n빌드 디렉토리 생성, build 디렉토리를 생성하고 이동합니다. 이 디렉토리에서 빌드 관련 파일들이 생성됩니다.\n\nmkdir build\ncd build\n\nCMake 구성, 상위 디렉토리(..)에 있는 CMakeLists.txt 파일을 사용하여 빌드 시스템을 구성합니다.\n\ncmake ..\n\n프로젝트 빌드, 현재 디렉토리(.)에 있는 빌드 파일을 사용하여 프로젝트를 빌드합니다. 이 명령어는 실제 컴파일 및 링크 과정을 수행합니다.\n\ncmake --build .\n\n실행 파일 실행, build 디렉토리 안에 생성된 hello_world 실행 파일을 실행합니다.\n\n./hello_world\n\n\n\n\n/\n├── CMakeLists.txt\n├── staticlib/\n│   ├── CMakeLists.txt\n│   ├── include/\n│   │   └── staticlib/\n│   │       └── add.h\n│   └── src/\n│       └── add.cpp\n├── sharedlib/\n│   ├── CMakeLists.txt\n│   ├── include/\n│   │   └── sharedlib/\n│   │       └── multiply.h\n│   └── src/\n│       └── multiply.cpp\n└── app/\n    ├── CMakeLists.txt\n    └── src/\n        └── main.cpp\n\n\n\nstaticlib/include/staticlib/add.h\n\n#pragma once\nint add(int a, int b);\n\nstaticlib/src/add.cpp\n\n#include \"staticlib/add.h\"\n\nint add(int a, int b) {\n    return a + b;\n}\n\nstaticlib/CMakeLists.txt\n\nadd_library(staticlib STATIC src/add.cpp): lib라는 정적 라이브러리 타겟을 생성하고, 소스 파일 src/add.cpp를 연결합니다. STATIC 키워드는 정적 라이브러리를 의미합니다.\ntarget_include_directories(staticlib PUBLIC include): lib 타겟에 헤더 파일 검색 경로를 추가합니다. PUBLIC 키워드는 이 라이브러리를 사용하는 타겟도 이 경로를 사용할 수 있음을 의미합니다.\n\n\nadd_library(staticlib STATIC src/add.cpp)\ntarget_include_directories(staticlib PUBLIC include)\n\n\n\n\n`sharedlib/src/multiply.cpp\n\n#include \"sharedlib/multiply.h\"\n\nint multiply(int a, int b) {\n    return a * b;\n}\n\nsharedlib/include/lib/multiply.h\n\n#pragma once\nint multiply(int a, int b);\n\nsharedlib/CMakeLists.txt\n\nadd_library(sharedlib SHARED src/sharedlib.cpp): sharedlib라는 공유 라이브러리 타겟을 생성하고, 소스 파일 src/sharedlib.cpp를 연결합니다. SHARED 키워드는 공유 라이브러리를 의미합니다.\ntarget_include_directories(sharedlib PUBLIC include): sharedlib 타겟에 헤더 파일 검색 경로를 추가합니다. PUBLIC 키워드는 이 라이브러리를 사용하는 타겟도 이 경로를 사용할 수 있음을 의미합니다.\n\n\nadd_library(sharedlib SHARED src/multiply.cpp)\ntarget_include_directories(sharedlib PUBLIC include)\n\n\n\n\napp/src/main.cpp\n\n#include &lt;iostream&gt;\n#include \"staticlib/add.h\"\n#include \"sharedlib/multiply.h\"\n\nint main() {\n    int a = 5, b = 3;\n\n    std::cout &lt;&lt; \"Addition: \" &lt;&lt; add(a, b) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Multiplication: \" &lt;&lt; multiply(a, b) &lt;&lt; std::endl;\n\n    return 0;\n}\n\napp/CMakeLists.txt\n\nadd_executable(_app src/main.cpp): _app이라는 실행 파일 타겟을 생성하고, 소스 파일 src/main.cpp를 연결합니다.\ntarget_link_libraries(_app PRIVATE lib sharedlib): _app 타겟에 lib와 sharedlib 라이브러리를 연결합니다. PRIVATE 키워드는 이 라이브러리들이 _app 타겟 내부에서만 사용됨을 의미합니다.\ntarget_include_directories(_app PRIVATE ...): _app 타겟에 lib 및 sharedlib의 헤더 파일 검색 경로를 추가합니다.\n\n\nadd_executable(_app src/main.cpp)\n\ntarget_link_libraries(_app\n    PRIVATE\n    staticlib\n    sharedlib\n)\n\ntarget_include_directories(_app\n    PRIVATE\n    ${CMAKE_CURRENT_SOURCE_DIR}/../staticlib/include\n    ${CMAKE_CURRENT_SOURCE_DIR}/../sharedlib/include\n)\n\n\n\n\nCMakeLists.txt\n\nadd_subdirectory() 명령을 사용하여 각 하위 디렉토리에 있는 CMakeLists.txt 파일을 포함합니다.\n\n\ncmake_minimum_required(VERSION 3.21)\nproject(LibsExample VERSION 1.0\n    DESCRIPTION \"A simple example demonstrating static and shared libraries\"\n    LANGUAGES CXX\n)\n\nadd_subdirectory(lib)\nadd_subdirectory(sharedlib)\nadd_subdirectory(app)\n\n\n\n\n\n빌드 디렉토리 생성\n\nmkdir build\ncd build\n\nCMake 구성\n\ncmake ..\n\n프로젝트 빌드\n\ncmake --build .\n\n실행 파일 실행:\n\n./app/_app\n\n실행 결과\n\nAddition: 8\nMultiplication: 15"
  },
  {
    "objectID": "notes/cpp_01.html#기본적인-cmake-사용법-및-cli를-통한-cmake-이해",
    "href": "notes/cpp_01.html#기본적인-cmake-사용법-및-cli를-통한-cmake-이해",
    "title": "C++ 개발 환경 구성과 CMake",
    "section": "",
    "text": "CMake를 사용해서 실행 파일을 만드는 과정을 통해 CMake의 기본적인 사용법을 연습하는 간단한 과정을 소개해드리겠습니다.\n\n소스 코드: src/main.cpp 파일에 “Hello, World!”를 출력하는 C++ 코드를 작성합니다.\nCMake 설정: CMakeLists.txt 파일에 CMake 프로젝트 설정을 정의하고, 실행 파일 타겟을 생성하고 소스 파일을 연결합니다.\n빌드: 명령 줄에서 CMake를 사용하여 프로젝트를 구성하고 빌드합니다.\n실행: 빌드된 실행 파일을 실행하여 “Hello, World!”가 출력되는지 확인합니다.\n\n\n\n\nsrc/main.cpp\n\n이 파일은 표준 출력 스트림을 사용하여 “Hello, World!”를 출력하는 간단한 C++ 프로그램입니다.\n#include &lt;iostream&gt;\n\nint main()\n{\n    std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; std::endl;\n    return 0;\n}\n\nCMakeLists.txt 파일\n\ncmake_minimum_required(VERSION 3.21): 이 명령어는 합니다. 3.21 버전 이상에서 이 프로젝트를 빌드해야 합니다.\nproject(...): 프로젝트 이름, 버전, 설명, 사용 언어 등을 설정합니다.\nadd_executable(hello_world): hello_world라는 실행 파일 타겟을 생성합니다.\ntarget_sources(hello_world PRIVATE src/main.cpp): hello_world 타겟에 소스 파일 src/main.cpp를 연결합니다. PRIVATE 키워드는 이 소스 파일이 현재 타겟에서만 사용됨을 의미합니다.\n\n\ncmake_minimum_required(VERSION 3.21) \n\nproject(HelloWorld VERSION 1.0\n  DESCRIPTION \"A simple Hello World project with CMake\"\n  LANGUAGES CXX\n)\n\nadd_executable(hello_world)\ntarget_sources(hello_world PRIVATE src/main.cpp)\n\n\n\n다음은 명령 줄에서 프로젝트를 빌드하고 실행하는 단계입니다.\n\n빌드 디렉토리 생성, build 디렉토리를 생성하고 이동합니다. 이 디렉토리에서 빌드 관련 파일들이 생성됩니다.\n\nmkdir build\ncd build\n\nCMake 구성, 상위 디렉토리(..)에 있는 CMakeLists.txt 파일을 사용하여 빌드 시스템을 구성합니다.\n\ncmake ..\n\n프로젝트 빌드, 현재 디렉토리(.)에 있는 빌드 파일을 사용하여 프로젝트를 빌드합니다. 이 명령어는 실제 컴파일 및 링크 과정을 수행합니다.\n\ncmake --build .\n\n실행 파일 실행, build 디렉토리 안에 생성된 hello_world 실행 파일을 실행합니다.\n\n./hello_world\n\n\n\n\n/\n├── CMakeLists.txt\n├── staticlib/\n│   ├── CMakeLists.txt\n│   ├── include/\n│   │   └── staticlib/\n│   │       └── add.h\n│   └── src/\n│       └── add.cpp\n├── sharedlib/\n│   ├── CMakeLists.txt\n│   ├── include/\n│   │   └── sharedlib/\n│   │       └── multiply.h\n│   └── src/\n│       └── multiply.cpp\n└── app/\n    ├── CMakeLists.txt\n    └── src/\n        └── main.cpp\n\n\n\nstaticlib/include/staticlib/add.h\n\n#pragma once\nint add(int a, int b);\n\nstaticlib/src/add.cpp\n\n#include \"staticlib/add.h\"\n\nint add(int a, int b) {\n    return a + b;\n}\n\nstaticlib/CMakeLists.txt\n\nadd_library(staticlib STATIC src/add.cpp): lib라는 정적 라이브러리 타겟을 생성하고, 소스 파일 src/add.cpp를 연결합니다. STATIC 키워드는 정적 라이브러리를 의미합니다.\ntarget_include_directories(staticlib PUBLIC include): lib 타겟에 헤더 파일 검색 경로를 추가합니다. PUBLIC 키워드는 이 라이브러리를 사용하는 타겟도 이 경로를 사용할 수 있음을 의미합니다.\n\n\nadd_library(staticlib STATIC src/add.cpp)\ntarget_include_directories(staticlib PUBLIC include)\n\n\n\n\n`sharedlib/src/multiply.cpp\n\n#include \"sharedlib/multiply.h\"\n\nint multiply(int a, int b) {\n    return a * b;\n}\n\nsharedlib/include/lib/multiply.h\n\n#pragma once\nint multiply(int a, int b);\n\nsharedlib/CMakeLists.txt\n\nadd_library(sharedlib SHARED src/sharedlib.cpp): sharedlib라는 공유 라이브러리 타겟을 생성하고, 소스 파일 src/sharedlib.cpp를 연결합니다. SHARED 키워드는 공유 라이브러리를 의미합니다.\ntarget_include_directories(sharedlib PUBLIC include): sharedlib 타겟에 헤더 파일 검색 경로를 추가합니다. PUBLIC 키워드는 이 라이브러리를 사용하는 타겟도 이 경로를 사용할 수 있음을 의미합니다.\n\n\nadd_library(sharedlib SHARED src/multiply.cpp)\ntarget_include_directories(sharedlib PUBLIC include)\n\n\n\n\napp/src/main.cpp\n\n#include &lt;iostream&gt;\n#include \"staticlib/add.h\"\n#include \"sharedlib/multiply.h\"\n\nint main() {\n    int a = 5, b = 3;\n\n    std::cout &lt;&lt; \"Addition: \" &lt;&lt; add(a, b) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Multiplication: \" &lt;&lt; multiply(a, b) &lt;&lt; std::endl;\n\n    return 0;\n}\n\napp/CMakeLists.txt\n\nadd_executable(_app src/main.cpp): _app이라는 실행 파일 타겟을 생성하고, 소스 파일 src/main.cpp를 연결합니다.\ntarget_link_libraries(_app PRIVATE lib sharedlib): _app 타겟에 lib와 sharedlib 라이브러리를 연결합니다. PRIVATE 키워드는 이 라이브러리들이 _app 타겟 내부에서만 사용됨을 의미합니다.\ntarget_include_directories(_app PRIVATE ...): _app 타겟에 lib 및 sharedlib의 헤더 파일 검색 경로를 추가합니다.\n\n\nadd_executable(_app src/main.cpp)\n\ntarget_link_libraries(_app\n    PRIVATE\n    staticlib\n    sharedlib\n)\n\ntarget_include_directories(_app\n    PRIVATE\n    ${CMAKE_CURRENT_SOURCE_DIR}/../staticlib/include\n    ${CMAKE_CURRENT_SOURCE_DIR}/../sharedlib/include\n)\n\n\n\n\nCMakeLists.txt\n\nadd_subdirectory() 명령을 사용하여 각 하위 디렉토리에 있는 CMakeLists.txt 파일을 포함합니다.\n\n\ncmake_minimum_required(VERSION 3.21)\nproject(LibsExample VERSION 1.0\n    DESCRIPTION \"A simple example demonstrating static and shared libraries\"\n    LANGUAGES CXX\n)\n\nadd_subdirectory(lib)\nadd_subdirectory(sharedlib)\nadd_subdirectory(app)\n\n\n\n\n\n빌드 디렉토리 생성\n\nmkdir build\ncd build\n\nCMake 구성\n\ncmake ..\n\n프로젝트 빌드\n\ncmake --build .\n\n실행 파일 실행:\n\n./app/_app\n\n실행 결과\n\nAddition: 8\nMultiplication: 15"
  }
]